*elixir-ext.txt*  Extras and extensions for *elixir*

Author:  Andrew Haust <https://andrew.hau.st>
License: Same terms as Vim itself (see |license|)


TABLE OF CONTENTS                           *elixir-ext*

INTRODUCTION................................|elixir-ext-introduction|
TEXT OBJECTS................................|elixir-ext-text-objects|
  * Maps....................................|elixir-ext-maps|
  * Functions...............................|elixir-ext-functions|
  * Sigils..................................|elixir-ext-sigils|
COMMANDS....................................|elixir-ext-commands|
 * Mix......................................|elixir-ext-commands-mix|
 * Editing..................................|elixir-ext-commands-editing|


INTRODUCTION                                *elixir-ext-introduction*

Provides extra utilities for working with Elixir outside of elixir.vim.

This plugin currently exists for me to work on Elixir stuff in one place.  In
the future, some of this functionality may get broken out into its own plugins
and perhaps some will get merged into elixir.vim.

This plugin makes no guarantees around NeoVim compatibility.  Reasonable
patches will be accepted to improve this situation but some of elixir-ext's
functionality depends on elixir.vim which is an unnecessary plugin for NeoVim.
NeoVim users are encouraged to checkout elixir-tools.nvim which has many of
the same features available here.


TEXT OBJECTS                                *elixir-text-objects*
                                            *elixir-text-object*
                                            *elixir-textobj*

Text objects are defined for function/macro/module defintions, conditionals,
sigils, maps, with, and list comprehensions

      Elixir construct             | Text Object Key
      -----------------------------+-------------------
      def/defp/defmacro/defmacrop  | f
      defmodule                    | M
      if/unless/case/cond          | c (c for conditional)
      %{}                          | m
      ~s"" etc.                    | S
      with                         | h
      for                          | f
      pipeline                     | |

These are fully configurable.
>
    let g:elixir_ext_textobj['d'] = 'f'
    let g:elixir_ext_textobj['f'] = 'l'
<

EDITING                                     *elixir-ext-editing*

                                            *elixir-ext-pipes*
                    NOTE: These commands depend on *elixir.vim*

                    NOTE: These commands only work for functions called with
                    parens.  A special case is made for `case`.

                    This plugin provides two commands for manipulating pipes:
                    |:FromPipe| and |:ToPipe|.  While it's quite robust it is
                    not perfect and will need to be formatted.  This is mostly
                    only true if un-piping a multiline data-structure.

                    For example:
>
                      %{
                        bar: baz()
                      }
                      |> foo("biz")
<
                    will become:
>
                      foo(
                        %{
                          bar: baz()
                        }, "biz")
<

                    But for simplier cases it works quite well, even with more
                    complex datastructres.  It is even aware of infix
                    operators, so you can actually convert between:
>
                      1 + 1
<
                    and
>
                      1
                      |> Kernel.+()
<

COMMANDS                                    *elixir-ext-commands*

:FromPipe[!]        Moves a piped argument into function parens.

                    The bang version will attempt to format.

                    See *elixir-ext-pipes* for more info.


                                            *:ToPipe* *elixir-ext-:ToPipe*
:ToPipe[!]          Converts a function call to an inline pipe.

                    The bang version creates a multi-line pipe.  This is
                    ignored if you are creating a nested pipe.  For example:
>
                      foo
                      |> bar(baz("biz"))
<
                    If you want to pipe `"biz"` into `baz()` it will always
                    produce:
>
                      foo
                      |> bar("biz" |> baz())
<
                    even if you use the bang version.

                    See *elixir-ext-pipes* for more info.

  vim:tw=78:et:ft=help:norl:

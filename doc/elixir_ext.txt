*elixir-ext.txt*  Extras and extensions for *elixir*

Author:  Andrew Haust <https://andrew.hau.st>
License: Same terms as Vim itself (see |license|)


TABLE OF CONTENTS                           *elixir-ext*

INTRODUCTION................................|elixir-ext-introduction|
TEXT OBJECTS................................|elixir-ext-text-objects|
  * Maps....................................|elixir-ext-maps|
  * Functions...............................|elixir-ext-functions|
  * Sigils..................................|elixir-ext-sigils|
EDITING.....................................|elixir-ext-editing|
NAVIGATION..................................|elixir-ext-navigation|
MIX.........................................|elixir-ext-mix|
PHOENIX.....................................|elixir-ext-phoenix|
COMMANDS....................................|elixir-ext-commands|
 * Mix......................................|elixir-ext-commands-mix|
 * Editing..................................|elixir-ext-commands-editing|
 * Navigation...............................|elixir-ext-commands-navigation|


INTRODUCTION                                *elixir-ext-introduction*

Provides extra utilities for working with Elixir outside of elixir.vim.

This plugin currently exists for me to work on Elixir stuff in one place.  In
the future, some of this functionality may get broken out into its own plugins
and perhaps some will get merged into elixir.vim.

This plugin makes no guarantees around NeoVim compatibility.  Reasonable
patches will be accepted to improve this situation but some of elixir-ext's
functionality depends on elixir.vim which is an unnecessary plugin for NeoVim.
NeoVim users are encouraged to checkout elixir-tools.nvim which has many of
the same features available here.


TEXT OBJECTS                                *elixir-text-objects*
                                            *elixir-text-object*
                                            *elixir-textobj*

Text objects are defined for function/macro/module defintions, conditionals,
sigils, maps, with, and list comprehensions

      Elixir construct         Text Object Key
      ___________________________________________

      def*                     "d"
      if, unless, case, cond   "c" (c for conditional)
      %{}                      "m"
      ~s"" etc.                "~"
      with                     "h"
      for                      "f"
      pipeline                 "|"

These are fully configurable.
>
    let g:elixir_ext_textobj['d'] = 'f'
    let g:elixir_ext_textobj['f'] = 'l'
<

EDITING                                     *elixir-ext-editing*

                                            *elixir-ext-pipes*
                    NOTE: These commands depend on *elixir.vim*

                    NOTE: These commands only work for functions called with
                    parens.  A special case is made for `case`.

                    This plugin provides two commands for manipulating pipes:
                    |:FromPipe| and |:ToPipe|.  While it's quite robust it is
                    not perfect and will need to be formatted.  This is mostly
                    only true if un-piping a multiline data-structure.

                    For example:
>
                      %{
                        bar: baz()
                      }
                      |> foo("biz")
<
                    will become:
>
                      foo(
                        %{
                          bar: baz()
                        }, "biz")
<

                    But for simplier cases it works quite well, even with more
                    complex datastructres.  It is even aware of infix
                    operators, so you can actually convert between:
>
                      1 + 1
<
                    and
>
                      1
                      |> Kernel.+()
<

PHOENIX                                     *elixir-ext-phoenix*


COMMANDS                                    *elixir-ext-commands*

Mix                                         *elixir-ext-commands-mix*

:{range}Mix[!] [args]
                    Run a mix command.  Uses |dispatch| if available.

                    Completion is available for tasks whose packages follow
                    the `mix/tasks/task.name.ex` file naming convention.

                    You can specifify the environment like so:
>
                      :Deps -test mix compile
<
                    This works for any environment you have specified outside
                    the standard "dev", "test", and "prod".  When called with
                    a bang [!], it will run the task in both dev and test
                    envs.


:{range}Deps [task] [args]
                    A wrapper around `mix deps` with some added functionality.

                    The standard tasks are available as well as an `add` task.
>
                      :Deps add live_view
<
                    With a range, it will operate on the current line.  This
                    can have different effects in different contexts.  For
                    now, this only works with deps.  For example, with you
                    cursor on the following line:
>
                      {:live_view, "~> 0.20"},
<
                    You could upgrade LiveView like so:
      >
                      :.Deps unlock
                      :.Deps update
<

:Generate           Unified generator command, aware of Phoenix and Ecto:
>
                      :Generate migration add_name_to_users
                      :Generate live Accounts User users name:string age:integer
<
                    These tasks are hardcoded to avoid possible naming
                    conflicts if a dynamic way were to be used.

                    You can add your own generators like so:
>
                      let g:elixir_ext_generators['custom'] = 'my_app.gen.custom'
<
                    PRs for other libraries are welcome!

Editing                                     *elixir-ext-commands-editing*

                                            *:FromPipe* *elixir-ext-:FromPipe*
:FromPipe[!]        Moves a piped argument into function parens.

                    The bang version will attempt to format.

                    See *elixir-ext-pipes* for more info.


                                            *:ToPipe* *elixir-ext-:ToPipe*
:ToPipe[!]          Converts a function call to an inline pipe.

                    The bang version creates a multi-line pipe.  This is
                    ignored if you are creating a nested pipe.  For example:
>
                      foo
                      |> bar(baz("biz"))
<
                    If you want to pipe `"biz"` into `baz()` it will always
                    produce:
>
                      foo
                      |> bar("biz" |> baz())
<
                    even if you use the bang version.

                    See *elixir-ext-pipes* for more info.

Navigation                                  *elixir-ext-commands-navigation*

                                            *:Emigration* *elixir-ext-:Emigration*
:Emigration         Edit a migration file.

                    Without arguments, it will navigate to the most recent
                    migration.

:{range}R [args]    Edit a "related" file.

                    This 

                    Support autocompletion.

  vim:tw=78:et:ft=help:norl:

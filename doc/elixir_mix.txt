*elixir-mix.txt*  Extras and extensions for *elixir*

Author:  Andrew Haust <https://andrew.hau.st>
License: Same terms as Vim itself (see |license|)

This plugin depends on elixir.vim
                       <https://github.com/elixir-editors/vim-elixir>

TABLE OF CONTENTS                           *elixir-mix*

INTRODUCTION................................|elixir-mix-introduction|
COMMANDS....................................|elixir-mix-commands|
 * Mix......................................|elixir-mix-commands-mix|
 * Editing..................................|elixir-mix-commands-editing|
TEXT OBJECTS................................|elixir-mix-text-objects|
  * Maps....................................|elixir-mix-maps|
  * Functions...............................|elixir-mix-functions|
  * Sigils..................................|elixir-mix-sigils|
  * Comments................................*elixir-mix-comments*


INTRODUCTION                                *elixir-mix-introduction*

Provides extra utilities on top of elixir.vim for working with the
Elixir programming language <https://elixir-lang.org>.

This plugin's focus is on Vim users - All features must be available to them.
Nvim compatibility isn't a non-goal and any reasonable patches for
nvim-support will be accepted, however, this is a Lua-free zone.


COMMANDS                                    *elixir-mix-commands*

Mix                                         *elixir-mix-commands-mix*
                                            *elixir-mix-:Mix*
                                            *:Mix*

:{range}Mix[!] [args]
                    Run a mix command.  Uses |dispatch| if available.

                    Completion is available for tasks whose packages follow
                    the `mix/tasks/task.name.ex` file naming convention.

                    You can specifify the environment like so:
>
                      :Mix -test mix compile
<
                    This works for any environment you have specified outside
                    the standard "dev", "test", and "prod".  When called with
                    a bang [!], it will run the task in both dev and test
                    envs.


:{range}Deps [task] [args]
                    A wrapper around `mix deps` with some added functionality.

                    The standard tasks are available as well as an `add` task.
>
                      :Deps add live_view
<
                    With a range, it will operate on the current line.  This
                    can have different effects in different contexts.  For
                    now, this only works with deps.  For example, with you
                    cursor on the following line:
>
                      {:live_view, "~> 0.20"},
<
                    You could upgrade LiveView like so:
      >
                      :.Deps unlock
                      :.Deps update
<

:Generate           Unified generator command, aware of Phoenix and Ecto:
>
                      :Generate migration add_name_to_users
                      :Generate live Accounts User users name:string age:integer
<
                    These tasks are hardcoded to avoid possible naming
                    conflicts if a dynamic way were to be used.

                    You can add your own generators like so:
>
                      let g:elixir_mix_generators['custom'] = 'my_app.gen.custom'
<
                    PRs for other libraries are welcome!


TEXT OBJECTS                                *elixir-mix-text-objects*
                                            *elixir-mix-text-object*
                                            *elixir-mix-textobj*

Text objects are defined for general Elixir blocks (do/end, fn/end), as well
as maps, sigils, and comments/docstrings.  There are some specialized objects
for the def* family of macros where the 'a' versions include meta like
specs, docstrings, etc.

Here is an overview:


  Elixir construct                 | Text Object  (mneumonic/notes)
  ---------------------------------+-----------------------------------------
  do/end blocks                    | d  (do)
  def[p]/defmarco[p]               | f
  def[p]/defmacro[p]               | F  (includes meta and function heads)
  defmodule                        | M
  %{}/%Foo{}                       | m  (map)
  ~s""/etc.                        | ~  (note the uppercase)
  #/@doc """/etc                   | c  (comment)



id                                          *elixir-mix-ie* *elixir-mix-ae*
ad                  A do/end block.  Currently brings "else" along with it.

                    These target all the builtin macros/special forms and work
                    well with them.  They are also designed to be general, so
                    should work with most custom macros.

                    Currently, with code written like so:
>
                      let foo = if condition? do
                        bar()
                      end
<
                    the "let foo = " will be included in "ad".


if                                          *elixir-mix-if* *elixir-mix-af*
af                                          *elixir-mix-iF* *elixir-mix-aF*
iF
aF                  A def macro including def, defp, defmacro, defmacrop,
                    defprotocol, and defimpl.  Useful for not having to worry
                    about being inside another block.

                    "af" will include docstrings, specs, comments, and other
                    meta.  This will only work so long as there are no blank
                    lines with the excpetion of within a docstring.  The "aF"
                    variant will only include the function itself.  "iF" is
                    included for convenience but is identical to "aF".

                    Additionally, "af"/"aF" will include either its trailing
                    blank line or its leading blank line in that order.


iM                                          *elixir-mix-iM* *elixir-mix-aM*
aM                  A module, ie, defmodule/end.  Useful for not
                    having to worry about being inside another block.


ic                                          *elixir-mix-ic* *elixir-mix-ac*
ac                  A comment or docstring.  It will target whichever your
                    cursor is on or ahead of.

im                                          *elixir-mix-im* *elixir-mix-am*
im                  A map or struct.

i~                                          *elixir-mix-i~* *elixir-mix-a~*
a~                  A sigil.  Works regardless of the delimiter.

EDITING                                     *elixir-mix-editing*

                                            *elixir-mix-pipes*
                    NOTE: These commands depend on *elixir.vim*

                    NOTE: These commands only work for functions called with
                    parens.  A special case is made for `case`.

                    This plugin provides two commands for manipulating pipes:
                    |:FromPipe| and |:ToPipe|.  While it's quite robust it is
                    not perfect and will need to be formatted.  This is mostly
                    only true if un-piping a multiline data-structure.

                    For example:
>
                      %{
                        bar: baz()
                      }
                      |> foo("biz")
<
                    will become:
>
                      foo(
                        %{
                          bar: baz()
                        }, "biz")
<

                    But for simplier cases it works quite well, even with more
                    complex datastructres.  It is even aware of infix
                    operators, so you can actually convert between:
>
                      1 + 1
<
                    and
>
                      1
                      |> Kernel.+()
<

COMMANDS                                    *elixir-mix-commands*

:FromPipe[!]        Moves a piped argument into function parens.

                    The bang version will attempt to format.

                    See *elixir-mix-pipes* for more info.


                                            *:ToPipe* *elixir-mix-:ToPipe*
:ToPipe[!]          Converts a function call to an inline pipe.

                    The bang version creates a multi-line pipe.  This is
                    ignored if you are creating a nested pipe.  For example:
>
                      foo
                      |> bar(baz("biz"))
<
                    If you want to pipe `"biz"` into `baz()` it will always
                    produce:
>
                      foo
                      |> bar("biz" |> baz())
<
                    even if you use the bang version.

                    See *elixir-mix-pipes* for more info.

  vim:tw=78:et:ft=help:norl:

*mixer.txt*  *mixer* mixes mixes your mix so you can mix while you mix

Author:  Andrew Haust <https://andrew.hau.st>
License: Same terms as Vim itself (see |license|)


TABLE OF CONTENTS                           *mixer*

INTRODUCTION                               |mixer-introduction|
TEXT OBJECTS                               |mixer-text-objects|
  # Do/end blocks                          |mixer-text-object-do-end|
  * Functions                              |mixer-functions|
  * Maps                                   |mixer-maps|
  * Sigils                                 |mixer-sigils|
  * Comments                               |mixer-comments|
  * options                                |mixer-text-objects-options|
MIX                                        |mixer-mix|
  * Commands                               |mixer-mix-commands|
  * Navigation                             |mixer-navigation|


INTRODUCTION                                *mixer-introduction*

Provides utilities for working with the Elixir programming language
<https://elixir-lang.org>.  For Vim users, this compliments elixir.vim
<https://github.com/elixir-lang/vim-elixir>.  This plugin is designed to work
with nvim as well, though nvim users may also want to evaluate
elixir-tools.nvim <https://github.com/elixir-tools/elixir-tools.nvim>.  This
plugin can be used along-side it.


TEXT OBJECTS                                *mixer-text-objects*
                                            *mixer-text-object*
                                            *mixer-textobj*

Text objects are defined for general Elixir blocks (do/end, fn/end), as well
as maps, sigils, and comments/docstrings.  There are some specialized objects
for the def* family of macros where the 'a' versions include specs,
docstrings, LiveView's `attr` and `slot`, as well as other meta.

Here is an overview:


    Elixir construct    | Text Object  (mneumonic/notes)
    --------------------+------------------------------------------------
    do/end blocks       | d  (do)
    do/end blocks       | D  (targets context like assignment)
    def[p]/defmarco[p]  | f
    def[p]/defmacro[p]  | F  (targets annotations and all function heads)
    defmodule           | M
    %{}/%Fooi.Bar{}     | m  (maps and structs)
    Sigils              | S  (note the uppercase)
    #/@doc """/etc      | c  (comment)


                    do/end blocks~
id                                          *mixer-ie* *mixer-ae*
ad
iD
aD                  A do/end block including function call.

                    Currently brings `else` along with it.

                    A reasonable effort is made for these to be as general as
                    possible and work with custom macros, not just the
                    builtins.  They work with both `do`/`end` syntax as
                    well as keyword syntax (`do: ...`).

                    The "aD" and "iD" versions will take extra context into
                    account.  For exampe, in the following code with the
                    cursor represented by `*`:
>
                      let foo =
                        if condition? do
                          bar(*)
                        end
<
                    typing `daD` will include the `let foo =` line.


                    function and macro definitions~
if                                          *mixer-if* *mixer-af*
af                                          *mixer-iF* *mixer-aF*
iF
aF                  A function definition including `def`, `defp`, `defmacro`, and
                    `defmacrop` as well as `defn` for Nx'ers.

                    "aF" will include any function annotations.  A small list
                    of well-known annotations are considered (definitively:
                    `@doc`, `@spec`, `@tag`, and `@requirements`) as well as
                    LiveView's `attr` and `slot` macros.  Otherwise, anything
                    between these and the function head and anything touching
                    the function head (no blank lines) will be included.

                    If necessary, it is possible to add your own by setting
                    `g:mixer_known_annotations` to a regex.  For example:
>
                      let g:mixer_known_annotations =
                        \ '\<my_macro\>\|@my_attribute\>'
<

                    module definitions~
iM                                          *mixer-iM* *mixer-aM*
aM                  A module definition.


                    maps and structs~
im                                          *mixer-im* *mixer-am*
am                  A map or struct.

                    With a count of `0`, as in `0yam`, this will target the
                    most outter map.


                    sigils~
iS                                          *mixer-i~* *mixer-a~*
aS                  A sigil.  Works regardless of the delimiter.


                    comments~
ic                                          *mixer-ic* *mixer-ac*
ac                  A comment.  Mostly just useful for formatting when
                    a comment is touching some code.


                    function arguments~
ia                                          *mixer-text-objects-arguments*
aa
                    A function argument.

                    These are only available if the plugin sideways.vim is
                    installed.  You can find this on www.vim.org or on github
                    at <https://github.com/AndrewRadev/sideways.vim>.


                                            *mixer-text-objects-options*

By default, text objects use the "seek" behaviour.  This means if you type
`daf` outside of a function, it will delete the next function searching
downward.  You may turn this off with the following setting:
>
  let g:mixer_textobj_seek = 0
<
Now your cursor must be on an object to operate on it.

Fine-grained control over which objects use seek is possible by providing
a comma comma-separate string where the possible values are:
>
  let g:mixer_textobj_seek_block = "block,module,map,sigil,comment"
<
This is the default.


COMMANDS                                    *mixer-commands*

                    Mix~
                                            *mixer-commands-mix*
                                            *mixer-:Mix*
                                            *:Mix*
:Mix[!] {flags} {args}
                    Run a mix command with autocomplete.

                    It will use an async library if available.  Currently,
                    it's only aware of |dispatch| though PRs for others are
                    welcome (see: https://github.com/sodapopcan/vim-mixer).
                    When called with a bang [!] it will call `:MyAsyncRunner!`
                    if supported.

                    You can specify the environment like so:
>
                      :Mix -test mix compile
<
                    This works for any custom environment you have outside the
                    standard "dev", "test", and "prod".  The `-` here simply
                    means "environment name."

                    You can also add environments onto the default like so:
>
                      :Mix +test mix compile
<
                    Assuming your default env is dev, this will run:
>
                      $ MIX_ENV=dev mix compile && MIX_ENV=test mix compile
<
                    If you are using an async runner and wish to run a command
                    synchronously using :Mix you may do so like this:
>
                      :Mix ! deps.get
<
                    Due to how vim commands are parsed, you can also call it
                    like this:
>
                      :Mix!! deps.get
<
                    The only difference between this and `:!mix` is that you
                    get autocomplete and environment flags.


                                            *mixer-:Deps* *:Deps*
:{range}Deps[!] {task} {args}
                    A wrapper around `:Mix deps` with some added behaviour.

                    When the current buffer is `mix.exs` and called without
                    {task} or {args} it will:

                      - |:write| the buffer if it has been modified
                      - run `mix deps get`

                    In any other buffer it will take you to `mix.exs` and
                    jump to your `deps` function.  This works regardless of
                    what you have named it.

                    The standard tasks are available as well as a special
                    `add` task.  This allows you to add deps to your mix.exs
                    by placing your cursor above where you would like to add
                    it and invoking the following:
>
                      :Deps add phoenix_test
<
                    This is only available if the current buffer is `mix.exs`.

                    Given a {range}, it will operate on those lines.  This is
                    probably most useful with the current line for example,
                    with your cursor on this line:
>
                      {:live_view, "~> 0.20"},
<
                    You can update LiveView by calling:
      >
                      :.Deps update
<
                    With the following lines visually selected:
>
                      {:floki, "~> 0.3"},
                      {:phoenix_test, "~> 1.7"},
                      {:pathex, "~> 2.5"},
                      {:image, "~> 0.5"}
<
                    Running
>
                      :'<,'>Deps update
<
                    will result in:
>
                      mix deps update floki phoenix_test pathex image
<
                    This is really more of a party trick as it's probably
                    pretty rare that the deps you want to update will be right
                    next to each other but het, here we are... !

                    This command's bang [!] behaviour  works the same as it
                    does for |:Mix|.  The environment flags (`-` and `+`) are
                    also available.


                                            *mixer-:Migrate* *:Migrate*
:{count}Migrate[!] {arg}
                    Run migrations with autocomplete.

                    {count} will be passed to `--step`.  {arg} is either
                    a path to or filename of a migration which will be passed
                    to `--to`.  This can be a relative or absolute path, or
                    simply the migration name.  The former does not work in
                    umbrella apps unless your cwd an app.

                    For example, if the current buffer is a migration you want
                    to migrate `--to`, you may do so with:
>
                      :Migrate %
<
                    This command's bang [!] behaviour  works the same as it
                    does for |:Mix|.  The environment flags (`-` and `+`) are
                    also available.

                    Only available in a mix project with Ecto.


                                            *mixer-:Rollback* *:Rollback*

:{count}Rollback[!] {args}
                    Rollback migrations with autocomplete.

                    Works just like |:Migrate| in reverse.

                    Only available in a mix project with Ecto.


                                            *mixer-:Gen* *:Gen*
:Gen                Unified generator command with autocomplete.

                    Run any `*.gen.*` task in your project without namesapce.

                    For example:
>
                      :Gen live Accounts User users name:string age:integer
                      :Gen migration add_name_to_users
<

                    Name collisions are resolved by appending the package
                    prefix separated by a dot (`.`).  For example, if you have
                    a Phoenix project that is using Guardian and you type
                    `:Gen sec<tab>` you will see:
>
                      :Gen secret.
                      secret.guardian secret.phx
<
                    Tasks are sorted by their non-namespaced names.

  vim:tw=78:et:ft=help:norl:

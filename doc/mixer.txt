*mixer.txt*  *mixer* mixes mixes your mix so you can mix while you mix

Author:  Andrew Haust <https://andrew.hau.st>
License: Same terms as Vim itself (see |license|)


TABLE OF CONTENTS                           *mixer*

INTRODUCTION                               |mixer-introduction|
TEXT OBJECTS                               |mixer-text-objects|
  # Do/end blocks                          |mixer-text-object-do-end|
  * Functions                              |mixer-functions|
  * Maps                                   |mixer-maps|
  * Sigils                                 |mixer-sigils|
  * Comments                               |mixer-comments|
  * options                                |mixer-text-objects-options|
MIX                                        |mixer-mix|
  * Commands                               |mixer-mix-commands|
  * Navigation                             |mixer-navigation|


INTRODUCTION                                *mixer-introduction*

Provides utilities for working with the Elixir programming language
<https://elixir-lang.org>.  For Vim users, this compliments elixir.vim
<https://github.com/elixir-lang/vim-elixir>.  This plugin is designed to work
with nvim as well, though nvim users may also want to evaluate
elixir-tools.nvim <https://github.com/elixir-tools/elixir-tools.nvim>.  This
plugin can be used along-side it.


TEXT OBJECTS                                *mixer-text-objects*
                                            *mixer-text-object*
                                            *mixer-textobj*

Text objects are defined for general Elixir blocks (do/end, fn/end), as well
as maps, sigils, and comments/docstrings.  There are some specialized objects
for the def* family of macros where the 'a' versions include specs,
docstrings, LiveView's `attr` and `slot`, as well as other meta.

Here is an overview:


    Elixir construct    | Text Object  (mneumonic/notes)
    --------------------+------------------------------------------------
    do/end blocks       | d  (do)
    do/end blocks       | D  (includes assignment and comments)
    def[p]/defmarco[p]  | f
    def[p]/defmacro[p]  | F  (includes annotations and all function heads)
    defmodule           | M
    %{}/%Fooi.Bar{}     | m  (maps and structs)
    Sigils              | S  (note the uppercase)
    #/@doc """/etc      | c  (comment)


                    do/end blocks~
id                                          *mixer-ie* *mixer-ae*
ad
iD
aD                  A do/end block including function call.

                    Currently brings `else` along with it.

                    A reasonable effort is made for these to be as general as
                    possible and work with custom macros, not just the
                    builtins.  They work with both `do`/`end` syntax as
                    well as keyword syntax (`do: ...`).

                    "aD" will include assignment (pattern matching) and
                    any comments.  For example, in the following code with the
                    cursor represented by `\%#`, typing `daD` will delete all
                    of the following:


>
                      # Set foo to bar()
                      # if `condition?` is `true`
                      let foo =
                        if condition? do
                          bar\%#()
                        end
<
                    Note that for comments to be included, they must be
                    touching the code block.  If separated by a blank line
                    they will be left alone.


                    function and macro definitions~
if                                          *mixer-if* *mixer-af*
af                                          *mixer-iF* *mixer-aF*
iF
aF                  A function definition including `def`, `defp`, `defmacro`, and
                    `defmacrop` as well as `defn` for Nx'ers.

                    "aF" will include any function annotations.  A small list
                    of well-known annotations are considered (definitively:
                    `@doc`, `@spec`, `@tag`, and `@requirements`) as well as
                    LiveView's `attr` and `slot` macros.  Otherwise, anything
                    between these and the function head and anything touching
                    the function head (no blank lines) will be included.

                    If necessary, it is possible to add your own by setting
                    `g:mixer_known_annotations` to a regex.  For example:
>
                      let g:mixer_known_annotations =
                        \ '\<my_macro\>\|@my_attribute\>'
<

                    module definitions~
iM                                          *mixer-iM* *mixer-aM*
aM                  A module definition.


                    maps and structs~
im                                          *mixer-im* *mixer-am*
am                  A map or struct.

                    With a count of `0`, as in `0yam`, this will target the
                    most outter map.


                    sigils~
iS                                          *mixer-i~* *mixer-a~*
aS                  A sigil.  Works regardless of the delimiter.


                    comments~
ic                                          *mixer-ic* *mixer-ac*
ac                  A comment.  Mostly just useful for formatting when
                    a comment is touching some code.


                    function arguments~
ia                                          *mixer-text-objects-arguments*
aa
                    A function argument.

                    These are only available if the plugin sideways.vim is
                    installed.  You can find this on www.vim.org or on github
                    at <https://github.com/AndrewRadev/sideways.vim>.


                                            *mixer-text-objects-options*

By default, text objects use the "seek" behaviour.  This means if you type
`daf` outside of a function, it will delete the next function searching
downward.  You may turn this off with the following setting:
>
  let g:mixer_textobj_seek = 0
<
Now your cursor must be on an object to operate on it.

Fine-grained control over which objects use seek is possible by providing
a comma comma-separate string where the possible values are:
>
  let g:mixer_textobj_seek = "block,module,map,sigil,comment"
<
This is the default.


COMMANDS                                    *mixer-commands*

                    Mix~
                                            *mixer-commands-mix*
                                            *mixer-:Mix*
                                            *:Mix*
:Mix[!] {-env}{+env} {args}
                    Run a mix command with autocomplete.

                    It will use an async library if available.  Currently,
                    it's aware of |dispatch|, |asyncrun|, and the lesser known
                    |asyncdo|.  The latter is by Elixir community member
                    @hauleth so I figured I'd include it :)  PRs for others
                    are welcome.  When called with a bang [!] it will call
                    `:MyAsyncRunner!`.  You may also configure it to use any
                    command you want:
>
                      let g:mixer_async_command = 'Make'
<
                    You can specify the environment like so:
>
                      :Mix -test mix compile
<
                    This works for any custom environment you have outside the
                    standard "dev", "test", and "prod".  The `-` here simply
                    means "environment name."

                    You can also add environments onto the default like so:
>
                      :Mix +test mix compile
<
                    Assuming your default env is dev, this will run:
>
                      $ MIX_ENV=dev mix compile && MIX_ENV=test mix compile
<
                    If you are using an async runner and wish to run a command
                    synchronously using `:Mix` (ie, get the output in the
                    terminal session), you may do so like this:
>
                      :Mix ! deps.get
<
                    Due to how Vim commands are parsed, you can also call it
                    as:
>
                      :Mix!! deps.get
<
                    The only difference between this and `:!mix` is that you
                    get autocomplete and environment flags.

                    This command is always available, even when not editing an
                    Elixir file.

                    A note on autocomplete: When editing a file in a Mix
                    project, its tasks will be populated and cached in the
                    background so that autocomplete is instant from first use.
                    When used outside of a mix project, there will be a slight
                    delay the first time you hit `<tab>` while it populates
                    the tasks.


                                            *mixer-:Deps* *:Deps*
:{range}Deps[!] {task} {args}
                    A wrapper around `:Mix deps` with some added behaviour.

                    When the current buffer is `mix.exs` and called without
                    {task} or {args} it will:

                      - |:write| the buffer if it has been modified
                      - run `mix deps get`

                    In any other buffer it will take you to `mix.exs` and
                    jump to your `deps` function.  This works regardless of
                    what you have named it.

                    The standard tasks are available as well as a special
                    `add` task.  This allows you to add deps to your mix.exs
                    by placing your cursor above where you would like to add
                    it and invoking the following:
>
                      :Deps add phoenix_test
<
                    This is only available if the current buffer is `mix.exs`.

                    Given a {range}, it will operate on those lines.  This is
                    probably most useful with the current line for example,
                    with your cursor on this line:
>
                      {:live_view, "~> 0.20"},
<
                    You can update LiveView by calling:
      >
                      :.Deps update
<
                    With the following lines visually selected:
>
                      {:floki, "~> 0.3"},
                      {:phoenix_test, "~> 1.7"},
                      {:pathex, "~> 2.5"},
                      {:image, "~> 0.5"}
<
                    Running
>
                      :'<,'>Deps update
<
                    will result in:
>
                      mix deps update floki phoenix_test pathex image
<
                    This is really more of a party trick as it's probably
                    pretty rare that the deps you want to update will be right
                    next to each other but hey, there it is!

                    This command's bang [!] behaviour works the same as it
                    does for |:Mix|.  Environment flags via `-` and `+` are
                    also available.


                                            *mixer-:Migrate* *:Migrate*
:{count}Migrate[!] {arg}
                    Run migrations with autocomplete.

                    {count} will be passed to `--step`.  {arg} is either
                    a path to or filename of a migration which will be passed
                    to `--to`.  This can be a relative or absolute path, or
                    simply the migration name.  The former does not work in
                    umbrella apps unless your cd into the app.

                    This command's bang [!] behaviour  works the same as it
                    does for |:Mix|.  Environment flags via `-` and `+` are
                    also available.

                    Only available in a mix project with Ecto.


                                            *mixer-:Rollback* *:Rollback*

:{count}Rollback[!] {args}
                    Rollback migrations with autocomplete.

                    Works just like |:Migrate| in reverse.

                    A fun trick with `:Rollback` is to navigate to a migration
                    file you want to rollback to and issue:
>
                      :Rollback %
<
                    This will rollback to this migration.  `:Migrate` works
                    the same way should you find yourself not wanting to fully
                    migrate back to latest.

                    Only available in a mix project with Ecto.


                                            *mixer-:Gen* *:Gen*
:Gen                Unified generator command with autocomplete.

                    Run any `*.gen.*` task in your project without having to
                    provide its namesapce.

                    For example:
>
                      :Gen live Accounts User users name:string age:integer
                      :Gen migration add_name_to_users
<

                    Name collisions are resolved by appending the package
                    prefix separated by a dot (`.`).  For example, if you have
                    a Phoenix project that is using Guardian and you type
                    `:Gen sec<tab>` you will see:
>
                      :Gen secret.
                      secret.guardian secret.phx
<
                    Tasks are sorted by their non-namespaced names.

  vim:tw=78:et:ft=help:norl:
